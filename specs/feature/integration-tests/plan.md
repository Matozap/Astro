# Implementation Plan: GraphQL Integration Tests

**Branch**: `feature/integration-tests` | **Date**: 2025-12-18 | **Spec**: spec.md
**Input**: Minimal integration tests for all GraphQL operations using Aspire testing, external payloads, snapshot testing, no FluentAssertions, no database assertions

## Summary

Implement a dedicated integration test project that verifies all GraphQL operations (queries and mutations) for both Products and Orders modules. Tests use .NET Aspire's `DistributedApplicationTestingBuilder` to spin up the real application with PostgreSQL, send GraphQL requests via HttpClient, and validate response structures using Verify snapshot testing. GraphQL payloads are stored in external files for maintainability.

## Technical Context

**Language/Version**: C# 14.0 / .NET 10.0
**Primary Dependencies**:
- Aspire.Hosting.Testing 13.1.0 (Aspire test host)
- Verify.Xunit 31.9.0 (snapshot testing)
- xUnit 2.9.3 (test framework)
- Shouldly 4.2.1 (simple assertions - existing project standard)
- Microsoft.NET.Test.Sdk 18.0.1 (test infrastructure)

**Storage**: PostgreSQL via Aspire (ephemeral for tests)
**Testing**: Integration tests only (functional GraphQL verification)
**Target Platform**: .NET Aspire 13.0.2 via DistributedApplicationTestingBuilder
**Project Type**: Test project referencing AppHost
**Constraints**:
- No FluentAssertions
- No database row/value assertions
- External GraphQL payload files
- Snapshot testing for response validation

## Constitution Check

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Clean Architecture & DDD | N/A | Test project, not domain code |
| II. CQRS Pattern | N/A | Tests existing CQRS implementations |
| III. Unit Test Coverage | PASS | Adding integration test coverage |
| IV. .NET Aspire Platform | PASS | Using Aspire.Hosting.Testing |
| V. Entity Framework Core | N/A | Tests don't directly use EF |
| VI. Modular Monolith | PASS | Tests verify modular GraphQL API |

**Gate Status**: PASS

## Project Structure

### Documentation (this feature)

```text
specs/feature/integration-tests/
├── plan.md              # This file
├── spec.md              # Feature specification
└── tasks.md             # Implementation tasks
```

### Source Code (new test project)

```text
tests/
└── Astro.IntegrationTests/
    ├── Astro.IntegrationTests.csproj
    ├── Infrastructure/
    │   ├── IntegrationTestBase.cs      # Base class with Aspire setup
    │   ├── GraphQLClient.cs            # Helper for GraphQL requests
    │   └── VerifyConfiguration.cs      # Verify scrubber settings
    ├── Products/
    │   ├── ProductQueryTests.cs
    │   ├── ProductMutationTests.cs
    │   └── Payloads/
    │       ├── GetProducts.graphql
    │       ├── GetProductById.graphql
    │       ├── CreateProduct.graphql
    │       ├── UpdateProduct.graphql
    │       ├── DeleteProduct.graphql
    │       ├── UpdateStock.graphql
    │       ├── AddProductImage.graphql
    │       └── RemoveProductImage.graphql
    ├── Orders/
    │   ├── OrderQueryTests.cs
    │   ├── OrderMutationTests.cs
    │   └── Payloads/
    │       ├── GetOrders.graphql
    │       ├── GetOrderById.graphql
    │       ├── CreateOrder.graphql
    │       ├── UpdateOrder.graphql
    │       ├── UpdateOrderStatus.graphql
    │       └── CancelOrder.graphql
    └── Snapshots/                       # Auto-generated by Verify
        └── *.verified.json
```

## Key Design Decisions

### 1. Aspire Testing Approach

Use `DistributedApplicationTestingBuilder.CreateAsync<Projects.Astro_AppHost>()` to launch the full application stack including PostgreSQL. This ensures tests run against the real GraphQL endpoint with actual database connectivity.

```csharp
var appHost = await DistributedApplicationTestingBuilder
    .CreateAsync<Projects.Astro_AppHost>();
await using var app = await appHost.BuildAsync();
await app.StartAsync();

using var httpClient = app.CreateHttpClient("astro-api");
```

### 2. External GraphQL Payloads

Store GraphQL operations as embedded resources in `.graphql` files:

```graphql
# GetProducts.graphql
query GetProducts {
  products {
    id
    name
    sku
    price
    isActive
  }
}
```

Load at runtime via helper method to keep test code minimal.

### 3. Snapshot Testing with Verify

Use Verify.Xunit to capture and compare GraphQL responses:

```csharp
[Fact]
public async Task GetProducts_ReturnsValidStructure()
{
    var response = await _client.ExecuteGraphQL("GetProducts");
    await Verify(response);
}
```

Verify automatically:
- Serializes response to JSON
- Creates `.verified.json` snapshot on first run
- Compares subsequent runs against snapshot
- Scrubs dynamic values (GUIDs, timestamps)

### 4. Verify Scrubbing Configuration

Configure Verify to handle dynamic values that change between test runs:

```csharp
VerifierSettings.ScrubMembers("id", "createdAt", "updatedAt");
VerifierSettings.AddScrubber(s => s.Replace(/* guid pattern */, "Guid_1"));
```

### 5. Minimal Test Code Pattern

Each test follows the same minimal pattern:

```csharp
[Fact]
public async Task OperationName_Scenario_ExpectedBehavior()
{
    // Arrange - payload loaded from file
    var payload = LoadPayload("OperationName");

    // Act
    var response = await SendGraphQL(payload);

    // Assert - snapshot comparison
    await Verify(response);
}
```

### 6. No Database Assertions

Tests verify:
- GraphQL responses have correct structure
- Operations don't throw unhandled errors
- Response shape matches expected schema

Tests do NOT verify:
- Specific row counts in database
- Exact data values returned
- Data persistence between tests

## Dependencies & Parallel Opportunities

### Package Dependencies

```xml
<PackageReference Include="Aspire.Hosting.Testing" Version="13.1.0" />
<PackageReference Include="Verify.Xunit" Version="31.9.0" />
<PackageReference Include="xunit" Version="2.9.3" />
<PackageReference Include="xunit.runner.visualstudio" Version="3.0.2" />
<PackageReference Include="Microsoft.NET.Test.Sdk" Version="18.0.1" />
<PackageReference Include="Shouldly" Version="4.2.1" />
```

### Project References

```xml
<ProjectReference Include="..\..\Astro.AppHost\Astro.AppHost.csproj" />
```

### Parallel Execution

- Product and Order test files can be developed in parallel
- All payload files can be created in parallel
- Snapshot files are auto-generated, no parallel concerns
- Test execution: xUnit handles parallelism, but Aspire tests may need [Collection] to share app instance

## Complexity Tracking

| Aspect | Approach | Rationale |
|--------|----------|-----------|
| App Hosting | DistributedApplicationTestingBuilder | Official Aspire testing pattern |
| Assertions | Verify snapshots + Shouldly | Minimal code, structural validation |
| Payloads | Embedded .graphql files | External, readable, maintainable |
| Dynamic Values | Verify scrubbing | Automatic GUID/timestamp handling |
| Test Isolation | Fresh app per test class | Clean state, no cross-test pollution |
